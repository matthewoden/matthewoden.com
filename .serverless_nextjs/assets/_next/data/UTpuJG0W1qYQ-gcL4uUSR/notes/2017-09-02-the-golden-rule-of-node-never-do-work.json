{
  "pageProps": {
    "post": {
      "mdxSource": {
        "compiledSource": "\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The other day in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://stl-tech.slack.com/messages/C0VTQRYEA/\"\n  }), \"STL #Node slack channel\"), \", a user\\nasked how to join two JSON payloads together. They queried a list of inventories (which had\\nusers), and a list of users (who were attached to inventories), and wanted\\nto know the best way to combine them in Javascript.\"), mdx(\"p\", null, \"I quickly threw together a method for zipping/reducing across collections\", mdx(\"a\", {\n    href: \"#1\"\n  }, mdx(\"sup\", null, \"1\")), \", but\\nalso warned them about breaking the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Golden Rule of Node\"), \":\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Don't \", mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"do\"), \" work in node. \", mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"Describe\"), \" work in node.\"))), mdx(\"h2\", {\n    \"id\": \"doing-work-is-data-manipulation\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#doing-work-is-data-manipulation\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }), mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"icon icon-link\"\n  }))), mdx(\"em\", {\n    parentName: \"h2\"\n  }, \"Doing\"), \" work is data manipulation\"), mdx(\"p\", null, \"Node servers are, for the most part, single-threaded applications. They\\ndepend heavily on non-blocking I/O for performance. Every time you rework data\\nas part of your server's response, you're hold up the queue of incoming requests.\"), mdx(\"p\", null, \"Of course, it's possible to spin up \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://nodejs.org/api/child_process.html\"\n  }), \"child processes\"), \"\\nand delegate this work to another thread. But \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/nodejs/node/issues/3145\"\n  }), \"sending data back and forth over IPC is slow\"), \",\\nand requires serializing/unserializing on each process, which blocks both threads\\nduring that time. It would seem that this kind of delegation just\\ncreates more work.\", mdx(\"a\", {\n    href: \"#2\"\n  }, mdx(\"sup\", null, \"2\"))), mdx(\"h2\", {\n    \"id\": \"describing-work-is-message-passing\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#describing-work-is-message-passing\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }), mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"icon icon-link\"\n  }))), mdx(\"em\", {\n    parentName: \"h2\"\n  }, \"Describing\"), \" work is message-passing\"), mdx(\"p\", null, \"Node shines as a message broker, transforming small requests into streaming\\nreplies. Think of your node app as a middle-manager, gathering requirements,\\nhandling bad requests, and delegating responsibility.\"), mdx(\"h3\", {\n    \"id\": \"practices-and-patterns-for-describing-work\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h3\"\n  }, {\n    \"href\": \"#practices-and-patterns-for-describing-work\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }), mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"icon icon-link\"\n  }))), \"Practices and patterns for describing work:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Avoid formatting the incoming request. Clients should pass in data exactly as\\nyou need it.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Get your data from the database exactly as your client expects it.\\nIf you need the data sorted, make that part of the query. If you need it\\naliased, and grouped? Do it in the query. Your database is always going to be\\nfaster at organizing data than your server.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Leave database responses as they are. If you've asked for exactly what you\\nneed, there's no point in mapping, filtering, or sorting the results.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Use static, parameterized queries whenever possible. Custom string-building/\\nquery-building is just more logic to keep track of, and more work to be done\\non every call.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"If you don't have any say over the format of the data (maybe you're\\ncalling another API), then minimize the work you have to do. Use streams and\\nsequences to manipulate the data as it arrives, rather than all at once.\"))), mdx(\"p\", null, \"In short, a valid request from the client should map to a static, parameterized\\nquery. The database's response should be attach onto a parameterized reply.\\nOutside of basic validation, your server shouldn't ever care about the\\ndata passing through it.\"), mdx(\"hr\", null), mdx(\"small\", null, mdx(\"a\", {\n    id: \"1\"\n  }), mdx(\"sup\", null, \"1\"), \" Regardless of whether or not something's a good idea, sometimes you just need to get things done.\", mdx(\"a\", {\n    id: \"2\"\n  }), mdx(\"sup\", null, \"2\"), \" This is part of why scaling out a Node service is typically done by spinning up more servers to run in parallel, rather than a using a single server that manages multiple threads.\"));\n}\n\n;\nMDXContent.isMDXComponent = true;",
        "renderedOutput": "<p>The other day in the <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://stl-tech.slack.com/messages/C0VTQRYEA/\">STL #Node slack channel</a>, a user\nasked how to join two JSON payloads together. They queried a list of inventories (which had\nusers), and a list of users (who were attached to inventories), and wanted\nto know the best way to combine them in Javascript.</p><p>I quickly threw together a method for zipping/reducing across collections<a href=\"#1\"><sup>1</sup></a>, but\nalso warned them about breaking the <em>Golden Rule of Node</em>:</p><blockquote><p><strong>Don&#x27;t <em>do</em> work in node. <em>Describe</em> work in node.</strong></p></blockquote><h2 id=\"doing-work-is-data-manipulation\"><a href=\"#doing-work-is-data-manipulation\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a><em>Doing</em> work is data manipulation</h2><p>Node servers are, for the most part, single-threaded applications. They\ndepend heavily on non-blocking I/O for performance. Every time you rework data\nas part of your server&#x27;s response, you&#x27;re hold up the queue of incoming requests.</p><p>Of course, it&#x27;s possible to spin up <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://nodejs.org/api/child_process.html\">child processes</a>\nand delegate this work to another thread. But <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/nodejs/node/issues/3145\">sending data back and forth over IPC is slow</a>,\nand requires serializing/unserializing on each process, which blocks both threads\nduring that time. It would seem that this kind of delegation just\ncreates more work.<a href=\"#2\"><sup>2</sup></a></p><h2 id=\"describing-work-is-message-passing\"><a href=\"#describing-work-is-message-passing\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a><em>Describing</em> work is message-passing</h2><p>Node shines as a message broker, transforming small requests into streaming\nreplies. Think of your node app as a middle-manager, gathering requirements,\nhandling bad requests, and delegating responsibility.</p><h3 id=\"practices-and-patterns-for-describing-work\"><a href=\"#practices-and-patterns-for-describing-work\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Practices and patterns for describing work:</h3><ul><li><p>Avoid formatting the incoming request. Clients should pass in data exactly as\nyou need it.</p></li><li><p>Get your data from the database exactly as your client expects it.\nIf you need the data sorted, make that part of the query. If you need it\naliased, and grouped? Do it in the query. Your database is always going to be\nfaster at organizing data than your server.</p></li><li><p>Leave database responses as they are. If you&#x27;ve asked for exactly what you\nneed, there&#x27;s no point in mapping, filtering, or sorting the results.</p></li><li><p>Use static, parameterized queries whenever possible. Custom string-building/\nquery-building is just more logic to keep track of, and more work to be done\non every call.</p></li><li><p>If you don&#x27;t have any say over the format of the data (maybe you&#x27;re\ncalling another API), then minimize the work you have to do. Use streams and\nsequences to manipulate the data as it arrives, rather than all at once.</p></li></ul><p>In short, a valid request from the client should map to a static, parameterized\nquery. The database&#x27;s response should be attach onto a parameterized reply.\nOutside of basic validation, your server shouldn&#x27;t ever care about the\ndata passing through it.</p><hr/><small><a target=\"_blank\" rel=\"noopener noreferrer\" id=\"1\"></a><sup>1</sup> Regardless of whether or not something&#x27;s a good idea, sometimes you just need to get things done.<a target=\"_blank\" rel=\"noopener noreferrer\" id=\"2\"></a><sup>2</sup> This is part of why scaling out a Node service is typically done by spinning up more servers to run in parallel, rather than a using a single server that manages multiple threads.</small>",
        "scope": {}
      },
      "frontMatter": {
        "wordCount": 478,
        "readingTime": {
          "text": "3 min read",
          "minutes": 2.38,
          "time": 142799.99999999997,
          "words": 476
        },
        "slug": "2017-09-02-the-golden-rule-of-node-never-do-work",
        "fileName": "2017-09-02-the-golden-rule-of-node-never-do-work.md",
        "title": "Node isn't where you do work.",
        "date": "2017-09-02",
        "summary": "Push work to other systems, and let node coordinate your flow.",
        "tags": ["node", "architecture"]
      }
    },
    "prev": {
      "title": "Common problems when using NPM Enterprise.",
      "date": "2017-08-15",
      "tags": ["node", "config"],
      "summary": "A better developer experience when using private registries",
      "draft": false,
      "slug": "2017-08-15-common-problems-with-npm-enterprise"
    },
    "next": {
      "title": "Setting up SSL for a single-instance deploy on Elastic Beanstalk, with Docker",
      "date": "2017-09-04",
      "tags": ["devops", "docker"],
      "draft": false,
      "summary": "A step by step guide to have https on your personal projects.",
      "slug": "2017-09-04-single-node-ssl-aws-elastic-beanstalk"
    }
  },
  "__N_SSG": true
}
